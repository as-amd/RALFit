
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!! P R I N T I N G   C O N T R O L S !!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!   general output occurs on stream out

     INTEGER :: out = 6

!    The level of output required.
!    print_level = 0 gives no output (DEFAULT),
!    print_level = 1 gives a summary at the end of the solve,
!    print_level = 2 prints one-line summary for every iteration,
!    print_level = 3 same as 2 but add more details,
!    print_level = 4 same as 3 & also prints one-line inner iteration info,
!    print_level = 5 same as 4 with very verbose (debugging) output.

     INTEGER :: print_level = 0

!    Print all the options and their values
     Logical :: print_options = .False.

!    Print by default banner header every 30 iterations
     Integer :: print_header = 30

!   any printing will start on this iteration

!$$     INTEGER :: start_print = - 1

!   any printing will stop on this iteration

!$$     INTEGER :: stop_print = - 1

!   the number of iterations between printing

!$$     INTEGER :: print_gap = 1

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!! M A I N   R O U T I N E   C O N T R O L S !!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!   the maximum number of iterations performed

     INTEGER :: maxit = 100

!   specify the model used. Possible values are
!
!      0  dynamic (*not yet implemented*)
!      1  Gauss-Newton (no 2nd derivatives)
!      2  second-order (exact Hessian)
!      3  hybrid (using Madsen, Nielsen and Tingleff's method)
!      4  tensor model (model must = 2)

     INTEGER :: model = 3

!   trust region or regularization?
!
!      1  trust region method
!      2  regularization

     INTEGER :: type_of_method = 1

!   specify the method used to solve the trust-region sub problem
!      1 Powell's dogleg
!      2 AINT method (of Yuji Nat.)
!      3 More-Sorensen
!      4 Galahad's DTRS

     INTEGER :: nlls_method = 4

!  which linear least squares solver should we use?

     INTEGER :: lls_solver = 1

!   overall convergence tolerances. The iteration will terminate when the
!   norm of the gradient of the objective function is smaller than
!      MAX( %stop_g_absolute, %stop_g_relative * norm of the initial gradient)
!   or if the norm of objective function is smaller than
!      MAX( %stop%f_absolute, %stop_f_relative * initial norm of the function)
!     or if the step is less than %stop_s

     REAL ( KIND = wp ) :: stop_g_absolute = 1.0e-5_wp
     REAL ( KIND = wp ) :: stop_g_relative = 1.0e-8_wp
     REAL ( KIND = wp ) :: stop_f_absolute = 1.0e-8_wp
     REAL ( KIND = wp ) :: stop_f_relative = 1.0e-8_wp
     REAL ( KIND = wp ) :: stop_s = epsmch


!   should we scale the initial trust region radius?

     integer :: relative_tr_radius = 0

!   if relative_tr_radius == 1, then pick a scaling parameter
!   Madsen, Nielsen and Tingleff say pick this to be 1e-6, say, if x_0 is good,
!   otherwise 1e-3 or even 1 would be good starts...

     real (kind = wp) :: initial_radius_scale = 1.0_wp

!   if relative_tr_radius /= 1, then set the
!   initial value for the trust-region radius (-ve => ||g_0||)

     REAL ( KIND = wp ) :: initial_radius = 100.0_wp

!   for the newton tensor model, allow a base tr raidius to allow an inherent
!   regularization in the problem that can't be changed
!   ( so we minimize 0.5 * (\sum (f_i)^2 + sigma_k ||s||^2) ), using another reg parameter
!   on top of this
!   (undocumented control variable)

     REAL ( KIND = wp ) :: base_regularization = 0.0_wp

     ! allow inherently the solution of a problem of the form
     !  min_x 1/2 ||r(x)||^2 + regularization_term * 1/ regularization_power * ||x||^regularization_term
     !
     ! this is done in two ways:
     !
     ! ** p = 2 **
     ! in this case, we solve a problem of the form
     !          min 0.5 || f(x) ||**2, where
     ! f:R^(n) -> R^(n+m)
     ! f_i(x) = r_i(x), i = 1,m
     ! f_i(x) = sqrt( regularization_term ) x_j, i = m + j, where j = 1,n
     ! This is implemented implicitly by updating
     !  ||f||**2 = ||r||**2 + regularization_term * ||x||**2
     !  J_f^Tf = J^Tr + regularization_term * x
     !  J_f^T J_f = J^T J + regularization_term * I
     !  md_f = md + 0.5 * regularization_term * ||x + d||**2
     !
     ! ** p .ne. 2 **
     ! here we solve a problem of the form
     !         min 0.5 || g(x) ||**2, where
     ! g:R^n -> R^(n+1)
     ! g_i(x) = r_i(x), i = 1,m
     ! g_i(x) = [(2*weight/power)**0.5 ] * ||x||**(power/2), i = m+1
     ! This is implemented implicitly by updating
     !  ||g||**2 = ||r||**2 + (2*weight/power) * ||x||**power
     !  J_g^T g = J^T r + weight ||x||**(power-2) x
     !  J_g^T J_g = J^T J + (weight * power / 2) * ||x||**(power-4) x x^T
     !  md_g = md + 0.5 * ||x||**(power-4) * weight *
     !             ( (2/power)**0.5 x^Tx + (power/2)**0.5 x^Td )**2
     !  and, if the full hessian was used
     !  md_g = md_g + weight * ||x||**(power-4)( x^Tx d^td + (d^tx)**2)
     integer :: regularization = 0
     REAL ( KIND = wp ) :: regularization_term = 1.0e-2_wp
     REAL ( KIND = wp ) :: regularization_power = 2.0_wp


!   maximum permitted trust-region radius

     REAL ( KIND = wp ) :: maximum_radius = 10.0_wp ** 8

!   a potential iterate will only be accepted if the actual decrease
!    f - f(x_new) is larger than %eta_successful times that predited
!    by a quadratic model of the decrease. The trust-region radius will be
!    increased if this relative decrease is greater than %eta_very_successful
!    but smaller than %eta_too_successful

     REAL ( KIND = wp ) :: eta_successful = 10.0_wp ** ( - 8 )! 10.0_wp ** ( - 8 )
     REAL ( KIND = wp ) :: eta_success_but_reduce = 10.0_wp ** ( - 8 ) !0.25_wp
     REAL ( KIND = wp ) :: eta_very_successful = 0.9_wp!0.75_wp!point9
     REAL ( KIND = wp ) :: eta_too_successful = 2.0_wp

!   on very successful iterations, the trust-region radius will be increased by
!    the factor %radius_increase, while if the iteration is unsuccessful, the
!    radius will be decreased by a factor %radius_reduce but no more than
!    %radius_reduce_max

     REAL ( KIND = wp ) :: radius_increase = 2.0_wp
     REAL ( KIND = wp ) :: radius_reduce = 0.5_wp
     REAL ( KIND = wp ) :: radius_reduce_max = 0.0625_wp

! Trust region update strategy
!    1 - usual step function
!    2 - continuous method of Hans Bruun Nielsen (IMM-REP-1999-05)
     integer :: tr_update_strategy = 1

!   if model=7, then the value with which we switch on second derivatives

     real ( kind = wp ) :: hybrid_switch = 0.1_wp

!   shall we use explicit second derivatives, or approximate using a secant
!   method

     LOGICAL :: exact_second_derivatives = .false.

!   use a factorization (dsyev) to find the smallest eigenvalue for the subproblem
!    solve? (alternative is an iterative method (dsyevx)
     LOGICAL :: subproblem_eig_fact = .FALSE. ! undocumented....

     ! use eigendecomposition in subproblem solve?
     LOGICAL :: use_ews_subproblem = .TRUE.

     ! This forces to call min_eig_symm without previously calling solve_spd_nocopy
     ! This option is used for code coverage and can be hidden from user.
     Logical :: force_min_eig_symm = .FALSE.

!   scale the variables?
!   0 - no scaling
!   1 - use the scaling in GSL (W s.t. W_ii = ||J(i,:)||_2^2)
!       tiny values get set to 1.0_wp
!   2 - scale using the approx to the Hessian (W s.t. W = ||H(i,:)||_2^2
     INTEGER :: scale = 1
     REAL(wp) :: scale_max = 1.0e11_wp
     REAL(wp) :: scale_min = 1.0e-11_wp
     LOGICAL :: scale_trim_min = .TRUE.
     LOGICAL :: scale_trim_max = .TRUE.
     LOGICAL :: scale_require_increase = .FALSE.

     logical :: calculate_svd_J = .false.

     logical :: setup_workspaces = .true.
     logical :: remove_workspaces = .true.

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!! M O R E - S O R E N S E N   C O N T R O L S !!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    integer  :: more_sorensen_maxits = 500
    real(wp) :: more_sorensen_shift = 1.0e-13_wp
    real(wp) :: more_sorensen_tiny = 10.0_wp * epsmch
    real(wp) :: more_sorensen_tol = 1.0e-3_wp

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!! H Y B R I D   C O N T R O L S !!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

! what's the tolerance such that ||J^T f || < tol * 0.5 ||f||^2 triggers a switch
    real(wp) :: hybrid_tol = 2.0_wp!0.02

! how many successive iterations does the above condition need to hold before we switch?
    integer  :: hybrid_switch_its = 1!3

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!! T E N S O R   M O D E L   C O N T R O L S !!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

! what regularization should we use?
    real(wp) :: reg_order = -1.0_wp

! which method shall we use to solve the inner problem?
! 1 - add in a base regularization parameter
! 2 - minimize a modified cost functional
    integer :: inner_method = 2

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!! O U T P U T   C O N T R O L S !!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

! Shall we output progess vectors at termination of the routine?
     logical :: output_progress_vectors = .false.

     logical :: update_lower_order = .true.

     ! C or Fortran storage of Jacobian?
     logical :: Fortran_Jacobian = .true.

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!! B O X   B O U N D   O P T I O N S !!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!    Memory size for the non-monotone linesearch
     Integer :: box_nFref_max = 4
!    Times the TR loop can fail
     Integer :: box_ntrfail = 2 
!    Kanzow sufficient decrease ratio (eq 25) Kanzow 2004
     Real(Kind=wp) :: box_gamma = 0.99995_wp
     Real(Kind=wp) :: box_decmin = 2.0_wp * 1.0e-16_wp ! macheps
!    Magic number to consider box bound (+/-) infinity
     Real(Kind=wp) :: box_bigbnd = 1.0e20_wp
!    Wolfe descent condition (0<\sigma1<1/2), curvature condition (0<\sigma2)
     Real(Kind=wp) :: box_wolfe_descent = 1.0e-4_wp
     Real(Kind=wp) :: box_wolfe_curvature = 0.9_wp
!    Tolerance to consider projected dir a descent direction
!    See LS STEP Section 4 p392 Kanzow 2014
     Real(Kind=wp) :: box_kanzow_power = 2.1_wp
!    sqrt(mcheps)
     Real(Kind=wp) :: box_kanzow_descent = 1.0e-8_wp
!    sqrt(mcheps)
     Real(Kind=wp) :: box_quad_model_descent = 1.0e-8_wp
!    Take projected TR step when TR test is Ok?
!    True  => take step
!    False => force a LS or PG step
     Logical       :: box_tr_test_step = .False.
!    Take projected  TR step when Wolfe test is Ok?
!    True  => take step
!    False => force a LS or PG step
     Logical       :: box_wolfe_test_step = .False.
!    Threshold to determine if the projection of TR direction
!    is too severe 0<tau_max<1
     Real(Kind=wp) :: box_tau_max = 0.25_wp
!    Max times TR iterations can fail without passing the various
!    descent tests: 2? 3? 5? Ignored when proj(x)==x
     Integer       :: box_max_ntrfail = 2
!    Number of consecutive times quadratic model matches f(x_k+1)
!    required before setting initial alpha step for PG step equal 
!    to scale_alpha*alpha_k-1
     Integer       :: box_quad_match = 1
!    Initial step scale (if quad_i >= box_quad_i)
     Real(Kind=wp) :: box_alpha_scale = 2.0_wp
!    Scaling factor to use when updating Delta from LS/PG step 
     Real(Kind=wp) :: box_Delta_scale = 2.0_wp
!    <dTR,-g> < tau_min in order to test for descent
     Real(Kind=wp) :: box_tau_min = 1.0e-4_wp
     Integer       :: box_ls_step_maxit = 20
!    LS type: 1 => Dennis-Schnable; 2 => Hager-Zhang
     Integer       :: box_linesearch_type = 1

