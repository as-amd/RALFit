\documentclass{spec}

\usepackage{amsfonts,bm,amsmath}
\usepackage{verbatim}
\usepackage{algorithm, algpseudocode}
\usepackage{caption}


\input{nlls_header.tex}
\newcommand{\scalarinteger}{is a scalar of type {\tt INTEGER} }
\newcommand{\scalarlogical}{is a scalar of type {\tt LOGICAL} }
\newcommand{\scalarcharacter}[1]{is a scalar of type {\tt CHARACTER} and length {\tt #1} }
\newcommand{\scalarintegerio}{is an \intentout scalar of type {\tt INTEGER} }
\newcommand{\scalarintegerii}{is an \intentin scalar of type {\tt INTEGER} }
\newcommand{\scalarreal}{is a scalar of package type\ }
\newcommand{\ronearrayinteger}[1]{is a rank-1 array of type {\tt INTEGER} and size {\tt #1} }
\newcommand{\ronearrayreal}[1]{is a rank-1 array of package type and size {\tt #1}\ }
\newcommand{\ronearrayrealii}[1]{is an \intentin rank-1 array of package type and size {\tt #1} }
\newcommand{\ronearrayrealiiopt}[1]{is an optional \intentin rank-1 array of package type and size {\tt #1} }
\newcommand{\ronearrayrealio}[1]{is an \intentout rank-1 array of package type and size {\tt #1} }
\newcommand{\ct}{\%}
\begin{document}

\hslheader

\hslsummary

\input{summary.tex}

%!!!!!!!!!!!!!!!!!!!!!!!!!!!!
\hslattributes
\hslversions{\versionum\ (\versiondate)}.
\hslIRDCZ Real (single, double).
\hsllanguage Fortran 2003 subset (F95+TR155581).
\hsldate January 2016.
\hslorigin The Numerical Analysis Group, Rutherford Appleton Laboratory.
\hslremark The development of this package was
partially supported by EPSRC grant EP/M025179/1.

%!!!!!!!!!!!!!!!!!!!!!!!!!!!
\newpage
\hslhowto

\subsection{Calling sequences}

Access to the package requires a {\tt USE} statement \\ \\
\indent\hspace{5mm}{\tt use ral\_nlls\_double}
% \noindent
% If it is required to use more than one module at the same time, the derived
% types  (see Section~\ref{derived types})
% must be renamed in one of the {\tt USE} statements.
\medskip

\noindent The user can then call one of the procedures:
\vspace{-0.1cm}
\begin{description}
\item {\tt NLLS\_SOLVE}  solves the non-linear least squares problem (\ref{eq:nlls_problem}).
\item {\tt NLLS\_ITERATE} performs one iteration for the non-linear least squares solver.
\end{description}

%%%%%%%%%%%%%%%%%%%%%% derived types %%%%%%%%%%%%%%%%%%%%%%%%

\hsltypes
\label{derived types}
For each problem, the user must employ the derived types defined by the
module to declare scalars of the types {\tt NLLS\_inform} and
{\tt NLLS\_options}.  If {\tt nlls\_iterate} is to be used, then 
a scalar of the type {\tt NLLS\_workspace} must also be defined.
The following pseudocode illustrates this.
\begin{verbatim}
      use nlls_module
      ...
      type (NLLS_inform) :: inform
      type (NLLS_options) :: options
      type (NLLS_workspace) :: work ! needed if nlls_iterate to be called
      ...
\end{verbatim}
The components of {\tt NLLS\_options} and {\tt NLLS\_inform} are explained
in Sections~\ref{typeoptions} and \ref{typeinform}.


%%%%%%%%%%%%%%%%%%%%%% argument lists %%%%%%%%%%%%%%%%%%%%%%%%
\hslarguments
\subsubsection{Optional arguments}\label{Optional arguments}

We use square brackets {\tt [ ]} to indicate \optional\ arguments.
In each
call, optional arguments follow the argument {\tt inform}.  Since we
reserve the right to add additional optional arguments in future
releases of the code, {\bf we strongly recommend that all optional
arguments be called by keyword, not by position}.

\subsubsection{Integer and package types}
%{\tt INTEGER} denotes default {\tt INTEGER} and
%{\tt INTEGER(long)} denotes {\tt INTEGER(kind=selected\_int\_kind(18))}.
The term {\bf package type} is used to mean
default real if the single precision version is being used and
double precision real for the double precision version.

\subsubsection{To solve the non-linear least squares problem}
\label{sec:solve}

To solve the non-linear least squares problem a call of the following form should be made:

\begin{verbatim}
   call nlls_solve(n, m, X, eval_r, eval_J, eval_Hf, params, options, inform[, weights])
\end{verbatim}

\begin{description}
\itt{n} \scalarintegerii that holds the number $n$ of
variables to be fitted; i.e., $n$ is the length of the unknown vector $\bm x$. 
\textbf{Restriction:} \texttt{n}$>${\tt 0}.

\itt{m} \scalarintegerii that holds the number $m$ of
data points available; i.e., $m$ is the number of residuals $r_i$.
\textbf{Restriction:} \texttt{m}$\geq$\texttt{n}

\itt{X} is an \intentinout\  rank-1 array of package type
and size {\tt n}.  On entry, it must hold the initial guess for $\bm x$, and on
successful exit it holds the solution to the non-linear least squares problem.

\itt{eval\_r} is a {\tt PROCEDURE} that, given a point $\iter{\vx}$, returns the vector $\vr(\iter{\vx})$.
Further details of the format required are given in Section~\ref{sec::function_eval}.

\itt{eval\_J} is a {\tt PROCEDURE} that, given a point $\iter{\vx}$,
returns the $m \times n$ Jacobian matrix, $\iter{\vJ}$, of $\vr$ evaluated at $\iter{\vx}$.
Further details of the format required are given in Section~\ref{sec::function_eval}.

\itt{eval\_Hf} is a {\tt PROCEDURE} that, given vectors $\vx \in \mathbb{R}^n$
and $\vr \in \mathbb{R}^m$, returns the quantity $\sum_{i=1}^m (\vr)_i \nabla^2 \vr_i (\vx)$.
Further details of the format required are given in Section~\ref{sec::function_eval}.  If {\tt NLLS\_options\%exact\_second\_derivative = .false.}, then this is not referenced.

\itt{params} is an \intentin\ scalar of class {\tt params\_base\_type} that holds parameters to
be passed to the user-defined routines {\tt eval\_r}, {\tt eval\_J}, and {\tt eval\_Hf}.
Further details of its use are given in Section~\ref{sec::function_eval}.

\itt{options}is an \intentin\  scalar  of type {\tt NLLS\_options}
(see Section~\ref{typeoptions}).

\itt{inform} is an \intentinout\ scalar of type
{\tt NLLS\_inform}. Its components provide information about the execution
of the subroutine, as explained in Section~\ref{typeinform}.

\itt{weights} \ronearrayrealiiopt{m}.  If present, {\tt weights} holds the square-roots of the 
diagonal entries of the weighting matrix, $\vW$, in (\ref{eq:nlls_problem}).  If absent, then the norm in (\ref{eq:nlls_problem}) is taken to be the 2-norm, that is, $\vW = I$.

\end{description}

\subsection{To iterate once}
\label{sec:iterate}
Alternatively, the user may step through the solution process one iteration at
a time by making a call of the following form:

\begin{verbatim}
   call nlls_iterate(n, m, X, w, eval_F, eval_J, eval_HF, params, options, inform[, weights])
\end{verbatim}

\begin{description}

\item[\texttt{n}, \texttt{m}, \texttt{eval\_F}, \texttt{eval\_J}, \texttt{eval\_HF}, \texttt{params}, \texttt{info} and \texttt{options}] are as described in Section~\ref{sec:solve}.

\itt{X} is an \intentinout\  rank-1 array of package type
and size {\tt n}.  On the first call, it must hold the initial guess for
$\bm x$. On return it holds the value of $\bm x$ at the current iterate, and
must be passed unaltered to any subsequent call to \texttt{nlls\_iterate()}.

\itt{w} is an \intentinout\ scalar of type \texttt{NLLS\_workspace}. It is used
to store the current state of the iteration and should not be altered by the
user.

\end{description}

The user may use the components \texttt{info\%convergence\_normf} and
\texttt{info\%convergence\_normg} to determine whether the iteration has
converged.

\subsection{User-supplied function evaluation routines}
\label{sec::function_eval}
To evaluate the residual, Jacobian and Hessian at a point, the user
must supply subroutines that perform this operation that the package
{\tt ral\_nlls} will call internally.

In order to pass user-defined data into the evaluation calls, {\tt params\_base\_type} is extended to a {\tt user\_type}, as follows:
\begin{verbatim}
   type, extends( params_base_type ) :: user_type
      ! code declaring components of user_type
   end type user_type
\end{verbatim}
We recommend this type is wrapped in a module with the user-defined routines
for evaluating the function, Jacobian, and Hessian.

The components of the extended type are accessed through a \texttt{select type}
construct:
\begin{verbatim}
   select type(params)
   type is(user_type)
     ! code that accesses components of params that were defined within user_type
   end select
\end{verbatim}

\subsubsection{For evaluating the function $\vr(\vx)$}
A subroutine must be supplied to calculate $\vr(\vx)$ for a given vector $\vx$. It
must implement the following interface:

\begin{verbatim}
abstract interface
   subroutine eval_r(n, m, params, x, r, status)
      integer, intent(in) :: n
      integer, intent(in) :: m
      class(params_base_type), intent(in) :: params
      double precision, dimension(n), intent(in) :: x
      double precision, dimension(m), intent(out) :: r
      integer, intent(inout) :: status
   end subroutine eval_r
end interface
\end{verbatim}

\begin{description}
   \itt{n, m, params} are passed unchanged as provided in the call to
      {\tt nlls\_solve}.

   \itt{x} holds the current point $\iter{\vx}$ at which to evaluate $\vr(\iter{\vx})$.

   \itt{r} must be set by the routine to hold the residual function
      evaluated at the current point $\iter{\vx}$, $\vr(\iter{\vx})$.

   \itt{status} is initialised to \texttt{0} before the routine is
      called. If it is set to a non-zero value by the routine, then 
      {\tt nlls\_solve}/{\tt nlls\_iterate} will exit with an error.
\end{description}

\subsubsection{For evaluating the function $\vJ = \nabla \vr(\vx)$}
A subroutine must be supplied to calculate $\vJ = \nabla \vr(\vx)$ for a given vector $\vx$. It
must implement the following interface:

\begin{verbatim}
abstract interface
   subroutine eval_J(n, m, params, x, J, status)
      integer, intent(in) :: n
      integer, intent(in) :: m
      class(params_base_type), intent(in) :: params
      double precision, dimension(n), intent(in)  :: x
      double precision, dimension(n*m), intent(out) :: J
      integer, intent(inout) :: status
  end subroutine eval_J
end interface
\end{verbatim}

\begin{description}
   \itt{n, m, params} are passed unchanged as provided in the call to
      {\tt nlls\_solve}.

   \itt{x} holds the current point $\iter{\vx}$ at which to evaluate
      $\vJ(\iter{\vx})$.

   \itt{J} must be set by the routine to hold the Jacobian of the residual
      function evaluated at the current point $\iter{\vx}$, $\vr(\iter{\vx})$.
      \texttt{J(i*m+j)} must be set to hold $\nabla_{x_j} r_i(\iter{\vx})$.

   \itt{status} is initialised to \texttt{0} before the routine is
      called. If it is set to a non-zero value by the routine, then
      {\tt nlls\_solve}/{\tt nlls\_iterate} will exit with an error.
\end{description}

\subsubsection{For evaluating the function $Hf = \sum_{i=1}^m r_i(\vx) \vW \nabla^2 r_i(\vx)$}
A subroutine must be supplied to calculate $Hf = \sum_{i=1}^m (\vr)_i \nabla^2 r_i(\vx)$ for given vectors $\vx \in \mathbb{R}^n$ and $\vr \in \mathbb{R}^m$. It must implement the following interface:

\begin{verbatim}
abstract interface
   subroutine eval_Hf_type(n, m, params, x, r, Hf, status)
       integer, intent(in) :: n
       integer, intent(in) :: m
       class(params_base_type), intent(in) :: params
       double precision, dimension(n), intent(in)  :: x
       double precision, dimension(m), intent(in)  :: r
       double precision, dimension(n*n), intent(out) :: Hf
       integer, intent(inout) :: status
     end subroutine eval_Hf_type
end interface
\end{verbatim}

\begin{description}
   \itt{n, m, params} are passed unchanged as provided in the call to
      {\tt nlls\_solve}.

   \itt{x} holds the current point $\iter{\vx}$ at which to evaluate $\vr(x)$.

   \itt{r} holds $\vW\vr(x)$, the (weighted) residual, as computed from vector returned by the last call to \texttt{eval\_r}.

   \itt{Hf} must be set by the routine to hold the matrix
      $\sum_{i = 1}^m (\vr)_i \nabla^2\comp{r}(\iter{\vx})$, held
      by columns as a vector.

   \itt{status} is initialised to \texttt{0} before the routine is called.
      If it is set to a non-zero value by the routine, then {\tt nlls\_solve}/
      {\tt nlls\_iterate} will exit with an error.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\subsection{The options derived data type}
\label{typeoptions}

The derived data type {\tt NLLS\_options}
is used to hold controlling data. The components  are automatically
given default values in the definition of the type.

\vspace{2mm}

\noindent {\bf Components that control printing}
\begin{description}

\itt{error} is a scalar of type {\tt INTEGER} with default value {\tt 6} that
is used as the output stream for error messages. If it is negative, these
messages will be suppressed.

\itt{out} is a scalar of type {\tt INTEGER} with default value {\tt 6}
that is used as the output stream for general messages. If it is negative, these messages will be suppressed.

\itt{print\_level} is a scalar of type {\tt INTEGER} with default value {\tt 0} that
controls the level of output required.
\begin{description}
\item{\tt $\leq$ 0} No informational output will occur.
\item{\tt = 1} Gives a one-line summary for each iteration.
\item{\tt = 2} As 1, plus gives a summary of the inner iteration for each iteration.
\item{\tt > 2} As 2, and gives increasingly verbose (debugging) output.
\end{description}
The default is {\tt diagnostics\_level} $=$ 0.
\end{description}

\noindent {\bf Components that control the main iteration}.

\begin{description}

\itt{maxit} \scalarinteger that gives an upper bound on the number
of iterations the algorithm is allowed to take before being stopped.  The default value is {\tt 100}.  This is not accessed if {\tt nlls\_iterate} is used.

\itt{model} \scalarinteger that specifies the model, $m_k(\cdot)$, used.  Possible values are
\begin{description}
  \item{\tt 1} Gauss-Newton (no Hessian).
  \item{\tt 2} Newton (exact Hessian).
%  \item{\tt 3} Barely second-order (Hessian matrix approximated by the identity).
  \item{\tt 9} Hybrid method (mixture of Gauss-Newton/(Quasi-)Newton, as determined by the package).
\end{description}
The default is {\tt model = 1}.

\itt{nlls\_method} \scalarinteger that specifies the method used to solve
(or approximate the solution to) the trust-region sub problem.  Possible values are
\begin{description}
  \item{\tt 1} Powell's dogleg method (approximates the solution).
  \item{\tt 2} The Adachi-Iwata-Nakatsukasa-Takeda (AINT) method.
  \item{\tt 3} The More-Sorensen method.
  \item{\tt 4} {\sc Galahad}'s {\sc DTRS} method
\end{description}
The default is {\tt nlls\_method = 1}.

\itt{stop\_g\_absolute} \scalarreal that specifies the absolute tolerance for convergence.

\itt{stop\_g\_relative} \scalarreal that specifies the relative tolerance for convergence.

\itt{relative\_tr\_radius} \scalarinteger that specifies whether the initial trust region
radius should be scaled.

\itt{initial\_radius\_scale} \scalarreal that specifies the scaling parameter for the initial trust region radius, which is only used if {\tt relative\_tr\_radius = 1}.

\itt{initial\_radius} \scalarreal that specifies the initial trust-region radius, $\Delta$.

\itt{maximum\_radius} \scalarreal that specifies the maximum size permitted for the trust-region radius.

\itt{eta\_successful} \scalarreal that specifies the smallest value of $\rho$ such that the step is accepted.

\itt{eta\_very\_successful} \scalarreal that specifies the value of $\rho$ after which the trust-region radius is increased.

\itt{eta\_too\_successful} \scalarreal that specifies that value of $\rho$ after which the step is accepted,
but keep the trust-region radius unchanged.

\itt{radius\_increase} \scalarreal that specifies the factor to increase the trust-region radius by.

\itt{radius\_reduce} \scalarreal that specifies the factor to decrease the trust-region radius by.

\itt{hybrid\_switch} \scalarreal that specifies the value, if {\tt model = 9},
at which second derivatives are used.

\itt{exact\_second\_derivatives} \scalarlogical that, if {\tt true}, signifies that the
exact second derivatives are available (and, if {\tt false}, approximates them using a secant method).

\itt{more\_sorensen\_maxits} \scalarinteger that, if {\tt nlls\_method = 3}, specifies the maximum number of iterations allowed in the More-Sorensen method.

\itt{more\_sorensen\_shift} \scalarreal that, if {\tt nlls\_method = 3}, specifies the shift to be used in the More-Sorensen method.

\itt{more\_sorensen\_tiny} \scalarreal that, if {\tt nlls\_method = 3}, specifies the value
below which numbers are considered to be essentially zero.

\itt{more\_sorensen\_tol} \scalarreal that, if {\tt nlls\_method = 3}, specifies the tolerance
to be used in the More-Sorensen method.

\itt{hybrid\_tol} \scalarreal that, if \(\|{\iter{\vJ}}^T \vW \vr(\vx_k) \|_2 < \mathtt{hybrid\_tol} * 0.5 \|\vr(\vx_k)\|_\vW^2\), switches to a \newline(quasi-)Newton method.

\itt{hybrid\_switch\_its} \scalarinteger that sets how many iterates in a row must
the condition in the definition of {\tt hybrid\_tol} hold before a switch.

\itt{output\_progress\_vectors} \scalarlogical that, if true, outputs the progress vectors {\tt nlls\_inform\%resvec} and {\tt nlls\_inform\%gradvec} at the end of the routine.

\end{description}


\subsection{The derived data type for holding information}
\label{typeinform}
The derived data type {\tt NLLS\_inform} is used
to hold information from the execution of {\tt nlls\_solve} and {\tt nlls\_iterate}.
The components are:
\begin{description}
      \itt{status} \scalarinteger that gives the exit status of the subroutine.  See Section~\ref{hslerrors} for details.
      \itt{error\_message} \scalarcharacter{80} that holds the error message corresponding to the exit status.
\itt{alloc\_status} \scalarinteger that gives the status of the last attempted allocation/deallocation.
\itt{bad\_alloc} \scalarcharacter{80} that holds the name of the array that was being allocated when an error was flagged.
\itt{iter} \scalarinteger that gives the total number of iterations performed.
\itt{f\_eval} \scalarinteger that gives the total number of evaluations of the objective function.
\itt{g\_eval} \scalarinteger that gives the total number of evaluations of the gradient of the objective function.
\itt{h\_eval} \scalarinteger that gives the total number of evaluations of the Hessian of the objective function.
\itt{convergence\_normf} \scalarinteger that tells us if the test on the size of \(\vr\) is satisfied.
\itt{convergence\_normg} \scalarinteger that tells us if the test on the size of the gradient is satisfied.
\itt{resvec} \ronearrayreal{iter+1} that, if {\tt nlls\_options\%output\_progress\_vectors=.true}, holds the vector of residuals.
\itt{gradvec} \ronearrayreal{iter+1} that, if {\tt nlls\_options\%output\_progress\_vectors=.true}, holds the vector of gradients.
\itt{obj} \scalarreal that holds the value of the objective function at the best estimate of the solution determined by the algorithm.
\itt{norm\_g} \scalarreal that holds the gradient of the objective function at the best estimate of the solution determined by the package.
\itt{scaled\_g} \scalarreal that holds the gradient of the objective function at the best estimate of the solution determined by the package.
\itt{external\_return} \scalarinteger that gives the error code that was returned by a call to an external routine.
\itt{external\_name} \scalarcharacter{80} that holds the name of the external code that flagged an error.
\end{description}

%%%%%%%%%%%%%%%%%%%%%% Warning and error messages %%%%%%%%%%%%%%%%%%%%%%%%

\hslerrors

A successful return from a subroutine in the package is indicated by
{\tt NLLS\_inform\%status} having the value zero.
A non-zero value is associated with an error message that by default will
be output on unit {\tt NLLS\_options\%error}.

\input{errors.tex}

\hslgeneral


\hslio
   Error messages on unit {\tt NLLS\_options\%error} and warning
   and diagnostic messages on unit \newline{\tt NLLS\_options\%out},
   respectively. These have default value {\tt 6};
   printing of these messages is suppressed if the relevant unit number
   is negative or if {\tt NLLS\_options\%print\_level} is negative.
\hslrestrictions {\tt m$\ge$n$\ge$1}.

\hslmethod
\label{method}

\input{method.tex}
% todo!

\hslexample

\input{example_text.tex}

\verbatiminput{../example/Fortran/nlls_example.f90}


\end{document}
