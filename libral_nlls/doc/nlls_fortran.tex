\documentclass{spec}

\usepackage{amsfonts,bm,amsmath}
\usepackage{verbatim}
% set the release and package names

\newcommand{\libraryname}{RAL}
\newcommand{\packagename}{NLLS}
\newcommand{\fullpackagename}{\libraryname\_\packagename}
\newcommand{\versionum}{0.5.0}
\newcommand{\versiondate}{15 January 2016}
\newcommand{\version}{\versionum}
\newcommand{\scalarinteger}{is a scalar of type {\tt INTEGER} }
\newcommand{\scalarlogical}{is a scalar of type {\tt LOGICAL} }
\newcommand{\scalarintegerio}{is an \intentout scalar of type {\tt INTEGER} }
\newcommand{\scalarintegerii}{is an \intentin scalar of type {\tt INTEGER} }
\newcommand{\scalarreal}{is a scalar of package type\ }
\newcommand{\ronearrayinteger}[1]{is a rank-1 array of type {\tt INTEGER} and size {\tt #1}}
\newcommand{\ronearrayreal}[1]{is a rank-1 array of package type and size {\tt #1}\ }
\newcommand{\ronearrayrealii}[1]{is an \intentin rank-1 array of package type and size {\tt #1}\ }
\newcommand{\ronearrayrealio}[1]{is an \intentout rank-1 array of package type and size {\tt #1}\ }
\newcommand{\vx}{ {\bm x} } % macro for a vector x
\newcommand{\vr}{ {\bm r} } % macro for a vector r
\newcommand{\vg}{ {\bm g} } % macro for a vector g
\newcommand{\vd}{ {\bm d} } % macro for a vector d
\newcommand{\vH}{ {\bm H} } % macro for a matrix H
\newcommand{\vJ}{ {\bm J} } % macro for a matrix J
\newcommand{\iter}[2][k]{ #2_{#1}^{}} % macro for an iteration
\newcommand{\comp}[2][i]{ #2_{#1}^{}} % macro for a component of a vector
\begin{document}

\hslheader

\hslsummary
{\tt \fullpackagename} computes a solution to the non-linear least-squares problem
\begin{equation}
\min_\vx \  F(\vx) := \frac{1}{2}\| \vr(\vx) \|_2^2,
\label{eq:nlls_problem}
\end{equation}
where $\vr(\vx) =(\comp[1]{r}(\vx), \comp[2]{r}(\vx),...,\comp[m]{r}(\vx))^T$ is the non-linear residual of 
some data that needs fitting.
% the fit of the data $y$ to some non-linear function ${\bm f} : \mathbb{R}^n \rightarrow \mathbb{R}^m$
% ($m>n$).  
% The $n$ variables that are fitted are $\vx=(x_1,x_2,...,x_n)^T$.
% \textcolor{blue}{Some confusion: the $y_i$ don't appear again.}

The algorithm is iterative.
At each point, $\iter{\vx}$, a quadratic model of the function
\[
F(\iter{\vx}) \approx \iter{m}(\vx) := {\iter{\vg}}^T \vx + \frac{1}{2} {\vx}^T \iter{\vH} \vx.
\]
is built.
The `ideal' values in this model are $\iter{\vg} = {\iter{\vJ}}^T\vr(\iter{\vx})$ and 
$\iter{\vH} = {\iter{\vJ}}^T\iter{\vJ} + \sum_{i = 1}^m \comp{r}(\iter{\vx}) \nabla^2 \comp{r}(\iter{\vx})$, 
where $\iter{\vJ}$ denotes the $m \times n$ Jacobian of $\vr(\vx)$ at the point $\iter{\vx}$
and $\iter{\vH}$ is the Hessian at $\iter{\vx}$.

Once the model has been formed, a trust-region sub-problem of the form
\[
\vd = \arg \min_{\vx} \ \iter{m} (\vx) \quad \mathrm{s.t.} \quad  \|\vx\|_B \leq \Delta,
\]
is solved, 
where $\Delta$ is the trust region radius and $B$ is a given symmetric positive definite matrix. 
The quantity
\[\rho = \frac{F(\iter{\vx}) - F(\iter{\vx} + \vd)}{\iter{m}(\iter{\vx}) - \iter{m}(\iter{\vx} + \vd)}\]
is then calculated.
If this is sufficiently large, the point is accepted and  $\iter[k+1]{\vx}$ is set to $\iter{\vx} + \vd$; if not, the trust-region radius, $\Delta$, 
is reduced and  the resulting new trust-region sub-problem is solved.  If the step is very successful -- in that $\rho$ is close to one -- 
the trust-region radius is increased.

This process continues until either the residual, $\|\vr(\iter{\vx})\|_2$, or a measure of the gradient,
$\|{\iter{\vJ}}^T\vr(\iter{\vx})\|_2 / \|\vr(\iter{\vx})\|_2$, is sufficiently small.


%!!!!!!!!!!!!!!!!!!!!!!!!!!!!
\hslattributes
\hslversions{\versionum\ (\versiondate)}.
\hslIRDCZ Real (single, double).
\hsllanguage Fortran 2003 subset (F95+TR155581).  
\hsldate January 2016. 
\hslorigin The Numerical Analysis Group, Rutherford Appleton Laboratory.
\hslremark The development of this package was 
partially supported by EPSRC grant EP/M025179/1.

%!!!!!!!!!!!!!!!!!!!!!!!!!!!
\newpage
\hslhowto

\subsection{Calling sequences}

Access to the package requires a {\tt USE} statement \\ \\
\indent\hspace{5mm}{\tt use nlls\_module} 
% \noindent 
% If it is required to use more than one module at the same time, the derived
% types  (see Section~\ref{derived types}) 
% must be renamed in one of the {\tt USE} statements.
\medskip

\noindent The user can then call the procedure:
\vspace{-0.1cm}
\begin{description}
\item {\tt NLLS\_SOLVE}  solves the non-linear least squares problem (\ref{eq:nlls_problem}).
\end{description}

%%%%%%%%%%%%%%%%%%%%%% derived types %%%%%%%%%%%%%%%%%%%%%%%%

\hsltypes
\label{derived types}
For each problem, the user must employ the derived types defined by the
module to declare scalars of the types {\tt NLLS\_inform}, and
{\tt NLLS\_options}.
The following pseudocode illustrates this.
\begin{verbatim}
      use nlls_module
      ...
      type (NLLS_inform) :: inform
      type (NLLS_options) :: options
      ...
\end{verbatim}
The components of {\tt NLLS\_options} and {\tt NLLS\_inform} are explained
in Sections~\ref{typecontrol} and \ref{typeinform}. 


%%%%%%%%%%%%%%%%%%%%%% argument lists %%%%%%%%%%%%%%%%%%%%%%%%
\hslarguments

\subsubsection{Integer and package types}
%{\tt INTEGER} denotes default {\tt INTEGER} and 
%{\tt INTEGER(long)} denotes {\tt INTEGER(kind=selected\_int\_kind(18))}.
The term {\bf package type} is used to mean
default real if the single precision version is being used and
double precision real for the double precision version.

\subsubsection{To solve the non-linear least squares problem}
\label{sec:factorize}

To solve the non-linear least squares problem a call of the following form should be made:

\begin{verbatim}
   call nlls_solve(n, m, X, evalF, eval_J, eval_H, params, options, inform)
\end{verbatim}

\begin{description}
\itt{n} \scalarintegerii that holds the number $n$ of 
variables to be fitted; i.e., $n$ is the length of the unknown vector $\bm x$.

\itt{m} \scalarintegerii that holds the number $m$ of 
data points available; i.e., $m$ is the number of functions $f_i$.
\textbf{Restriction:} \texttt{m},\texttt{n}$>$\texttt{0}

\itt{X} is an \intentinout\  rank-1 array of package type 
and size {\tt n}.  On entry, it must hold the initial guess for $\bm x$, and on 
successful exit it holds the solution to the non-linear least squares problem.

\itt{eval\_f} is a {\tt PROCEDURE} that, given a point $\iter{\vx}$, returns the vector $\vr(\iter{\vx})$.  
Further details of the format required are given in Section~\ref{sec::function_eval}.

\itt{eval\_J} is a {\tt PROCEDURE} that, given a point $\iter{\vx}$, 
returns the $m \times n$ Jacobian matrix, $\iter{\vJ}$, of $\vr$ at $\iter{\vx}$.  
Further details of the format required are given in Section~\ref{sec::function_eval}.

\itt{eval\_Hf} is a {\tt PROCEDURE} that, given a point $\iter{\vx}$
and function $\vr(\iter{\vx})$, returns the second-order terms of the Hessian at $\iter{\vx}$. 
Further details of the format required are given in Section~\ref{sec::function_eval}.

\itt{params} is an \intentin\ scalar of class {\tt params\_base\_type} that holds parameters to 
be passed to the user-defined routines {\tt eval\_f}, {\tt eval\_j}, and {\tt eval\_hf}. 
Further details of its use are given in Section~\ref{sec::function_eval}.

\itt{options}is an \intentin\  scalar  of type {\tt NLLS\_options}
(see Section~\ref{typecontrol}).

\itt{inform} is an \intentinout\ scalar of type 
{\tt NLLS\_inform}. Its components provide information about the execution
of the subroutine, as explained in Section~\ref{typeinform}.


\end{description}


\subsection{User-supplied function evaluation routines}
\label{sec::function_eval}
In order to evaluate the function, Jacobian and Hessian at a point, the user
must supply subroutines that perform this operation that the code
{\tt ral\_nlls} will call internally.  

In order to pass user-defined data into the evaluation calls, {\tt params\_base\_type} may be extended to a {\tt user\_type}, as follows:
\begin{verbatim}
   type, extends( params_base_type ) :: user_type
      ! code declaring components of user_type 
   end type user_type
\end{verbatim}
We recommend this type is wrapped in a module with the user-defined routines
for evaluating the function, Jacobian, and Hessian.

The components of the extended type may be used through a \texttt{select type}
construct:
\begin{verbatim}
   select type(params)
   type is(user_type)
     ! code that accesses components of params that were defined within user_type 
   end select
\end{verbatim}

\subsubsection{For evaluating the function $r(x)$}
A subroutine must be supplied to calculate $r(x)$ for a given vector $x$. It
must implement the following interface:

\begin{verbatim}
abstract interface
   subroutine eval_r(n, m, params, x, r, status)
      integer, intent(in) :: n
      integer, intent(in) :: m
      class(params_base_type), intent(in) :: params
      real(wp), dimension(n), intent(in) :: x
      real(wp), dimension(m), intent(out) :: r
      integer, intent(inout) :: status
   end subroutine eval_r
end interface
\end{verbatim}

\begin{description}
   \itt{n, m, params} are passed unchanged as provided in the call to
      {\tt nlls\_solve}.

      \itt{x} holds the current point $\iter{\vx}$ at which to evaluate $\vr(\iter{\vx}$.
  
   \itt{r} must be set by the routine to hold the residual function 
      evaluated at the current point $\iter{\vx}$, $\vr(\iter{\vx})$.

   \itt{status} is initialised to \texttt{0} before the routine is
      called. If it is set to a non-zero value by the routine, then on return
      the {\tt nlls\_solve} subroutine will exit with an error.
\end{description}

\subsubsection{For evaluating the function $J = \nabla \vr(\iter{\vx})$}
A subroutine must be supplied to calculate $J = \nabla \vr(\iter{\vx})$ for a given vector $x$. It
must implement the following interface:

\begin{verbatim}
abstract interface
   subroutine eval_J(n, m, params, x, J, status)
      integer, intent(in) :: n
      integer, intent(in) :: m
      class(params_base_type), intent(in) :: params
      double precision, dimension(n), intent(in)  :: x
      double precision, dimension(n*m), intent(out) :: J
      integer, intent(inout) :: status
  end subroutine eval_J
end interface
\end{verbatim}

\begin{description}
   \itt{n, m, params} are passed unchanged as provided in the call to
      {\tt nlls\_solve}.

   \itt{x} holds the current point $\iter{\vx}$ at which to evaluate
      $J(\iter{\vx})$.
  
   \itt{J} must be set by the routine to hold the Jacobian of the residual
      function evaluated at the current point $\iter{\vx}$, $\vr(\iter{\vx})$.
      \texttt{J(i*m+j)} must be set to hold $\nabla_{x_j} r_i(\iter{\vx})$.
       
   \itt{status} is initialised to \texttt{0} before the routine is
      called. If it is set to a non-zero value by the routine, then on return
      the {\tt ral\_nlls} subroutine will exit with an error.
\end{description}

\subsubsection{For evaluating the function $HF = \sum_{i=1}^m \vr_i(x) \nabla^2 \vr_i(x)$}
A subroutine must be supplied to calculate $HF = \sum_{i=1}^m \vr_i(x) \nabla^2 \vr_i(x)$ for a given vector $x$. It must implement the following interface:

\begin{verbatim}
abstract interface
   subroutine eval_hf_type(n, m, params, x, r, HF, status)
       integer, intent(in) :: n
       integer, intent(in) :: m
       class(params_base_type), intent(in) :: params
       double precision, dimension(n), intent(in)  :: x
       double precision, dimension(m), intent(in)  :: r
       double precision, dimension(n*n), intent(out) :: HF
       integer, intent(inout) :: status
     end subroutine eval_hf_type
end interface
\end{verbatim}

\begin{description}
   \itt{n, m, params} are passed unchanged as provided in the call to
      {\tt nlls\_solve}.

   \itt{x} holds the current point $\iter{\vx}$ at which to evaluate $\vr(x)$.
  
   \itt{r} holds $\vr(x)$, as returned by a previous call to \texttt{eval\_r}.

   \itt{HF} must be set by the routine to holds the matrix
      $\sum_{i = 1}^m \comp{r}(\iter{\vx})\nabla^2\comp{r}(\iter{\vx})$, held
      by columns as a vector.

   \itt{status} is initialised to \texttt{0} before the routine is called.
      If it is set to a non-zero value by the routine, then on return
      the {\tt nlls\_solve} subroutine will exit with an error.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\subsection{The control derived data type}
\label{typecontrol} 

The derived data type {\tt NLLS\_options} 
is used to hold controlling data. The components  are automatically 
given default values in the definition of the type.

\vspace{2mm}

\noindent {\bf Components that control printing}
\begin{description}

\itt{error} is a scalar of type {\tt INTEGER} with default value {\tt 6} that
is used as the output stream for error messages. If it is negative, these
messages will be suppressed.  

\itt{out} is a scalar of type {\tt INTEGER} with default value {\tt 6}
that is used as the output stream for general messages. If it is negative, these messages will be suppressed. 

\itt{print\_level} is a scalar of type {\tt INTEGER} with default value {\tt 0} that 
controls the level of output required. 
\begin{description} 
\item{\tt $\leq$ 0} No informational output will occur.
\item{\tt = 1} As 0, plus gives a one-line summary for each iteration.
\item{\tt = 2} As 1, plus gives a summary of the inner iteration for each iteration.
\item{\tt > 3} As 3, and gives increasingly verbose (debugging) output.
\end{description}
The default is {\tt diagnostics\_level} $=$ 0.
\end{description}

\noindent {\bf Components that control the main iteration}.

\begin{description}

\itt{maxit} \scalarinteger that gives an upper bound on the number
of iterations the algorithm is allowed to take before being stopped.  The default value is {\tt 100}.

\itt{model} \scalarinteger that specifies the model, $m_k(\cdot)$, used.  Possible values are 
\begin{description}
  \item{\tt 1} Gauss-Newton (no Hessian).
  \item{\tt 2} Newton (exact Hessian).
%  \item{\tt 3} Barely second-order (Hessian matrix approximated by the identity).
  \item{\tt 9} Hybrid method (mixture of Gauss-Newton/Newton as appropriate).
\end{description}
The default is {\tt model = 1}.

\itt{nlls\_method} \scalarinteger that specifies the method used to solve 
(or approximate the solution to) the trust-region sub problem.  Possible values are
\begin{description}
  \item{\tt 1} Powell's dogleg method (approximates the solution).
  \item{\tt 2} The Adachi-Iwata-Nakatsukasa-Takeda (AINT) method.
  \item{\tt 3} The More-Sorensen method.
  \item{\tt 4} Galahad's DTRS method
\end{description}
The default is {\tt nlls\_method = 1}.

\itt{stop\_g\_absolute} \scalarreal that specifies the absolute tolerance for convergence.

\itt{stop\_g\_relative} \scalarreal that specifies the relative tolerance for convergence.

\itt{relative\_tr\_radius} \scalarinteger that specifies whether the initial trust region 
radius should be scaled.

\itt{initial\_radius\_scale} \scalarreal that specifies the scaling parameter for the initial trust region radius, which is only used if {\tt relative\_tr\_radius = 1}.

\itt{initial\_radius} \scalarreal that specifies the initial trust-region radius, $\Delta$.

\itt{maximum\_radius} \scalarreal that specifies the maximum size permitted for the trust-region radius.

\itt{eta\_successful} \scalarreal that specifies the smallest value of $\rho$ such that we accept the step.  

\itt{eta\_very\_successful} \scalarreal that specifies the value of $\rho$ after which we increase the trust-region radius.

\itt{eta\_too\_successful} \scalarreal that specifies that value of $\rho$ after which we accept the step, 
but keep the trust-region radius unchanged.

\itt{radius\_increase} \scalarreal that specifies the factor to increase the trust-region radius by.

\itt{radius\_reduce} \scalarreal that specifies the factor to decrease the trust-region radius by.

\itt{hybrid\_switch} \scalarreal that specifies the value, if {\tt nlls\_method = 9}, 
at which we switch to second derivatives.

\itt{exact\_second\_derivatives} \scalarlogical that, if {\tt true}, signifies that the
exact second derivatives are available (and, if {\tt false}, approximates them using a secant method).

\itt{more\_sorensen\_maxits} \scalarinteger that, if {\tt nlls\_method = 3}, specifies the maximum number of iterations allowed in the More-Sorensen method.

\itt{more\_sorensen\_shift} \scalarreal that, if {\tt nlls\_method = 3}, specifies the shift to be used in the More-Sorensen method.

\itt{more\_sorensen\_tiny} \scalarreal that, if {\tt nlls\_method = 3}, specifies the value 
below which we consider numbers to be essentially zero.

\itt{more\_sorensen\_tol} \scalarreal that, if {\tt nlls\_method = 3}, specifies the tolerance
to be used in the More-Sorensen method.

\itt{hybrid\_tol} \scalarreal that, if \(\|J^T f \| < \mathtt{hybrid\_tol} * 0.5 \|f\|^2\), switches to a (quasi-)Newton method.

\itt{hybrid\_switch\_its} \scalarinteger that sets how many iterates in a row must 
the condition in the definition of {\tt hybrid\_tol} hold before a switch.

\itt{output\_progress\_vectors} \scalarlogical that, if true, outputs the progress vectors at the end of the routine.

\end{description}


\subsection{The derived data type for holding information}
\label{typeinform} 
The derived data type {\tt NLLS\_inform} is used
to hold information from the execution of {\tt nlls\_solve}.
The components are:
\begin{description}
      \itt{status} \scalarinteger that gives the exit status of the subroutine.  See Section~\ref{hslerrors} for details.
\itt{alloc\_status} \scalarinteger that gives the status of the last attempted allocation/deallocation.
\itt{iter} \scalarinteger that gives the total number of iterations performed.
\itt{f\_eval} \scalarinteger that gives the total number of evaluations of the objective function.
\itt{g\_eval} \scalarinteger that gives the total number of evaluations of the gradient of the objective function.
\itt{h\_eval} \scalarinteger that gives the total number of evaluations of the Hessian of the objective function.
\itt{convergence\_normf} \scalarinteger that tells us if the test on the size of \(f\) is satisfied.
\itt{convergence\_normg} \scalarinteger that tells us if the test on the size of the gradient is satisfied.
\itt{resvec} \ronearrayreal{iter+1} that holds the vector of residuals
\itt{gradvec} \ronearrayreal{iter+1} that holds the vector of gradients.
\itt{obj} \scalarreal that holds the value of the objective function at the best estimate of the solution determined by the algorithm.
\itt{norm\_g} \scalarreal that holds the gradient of the objective function at the best estimate of the solution determined by the algorithm.
\end{description}

%%%%%%%%%%%%%%%%%%%%%% Warning and error messages %%%%%%%%%%%%%%%%%%%%%%%%

\hslerrors

A successful return from a subroutine in the package is indicated by 
{\tt NLLS\_inform$\%$status} having the value zero.  
A non-zero value is associated with an error message that by default will  
be output on unit {\tt NLLS\_control$\%$error}. 

Possible values are:
\begin{description}
\item{} {\tt -1} Maximum number of iterations reached without convergence.
\item{} {\tt -2} Error from evaluating a function/Jacobian/Hessian.
\item{} {\tt -3} Unsupported choice of model.
\item{} {\tt -4} Error return from an {\tt lapack} routine.
\end{description}

\hslgeneral


\hslio 
   Error messages on unit {\tt NLLS\_control$\%$error} and warning
   and diagnostic messages on unit {\tt NLLS\_control$\%$out},
   respectively. These have default value {\tt 6};
   printing of these messages is suppressed if the relevant unit number
   is negative or if {\tt NLLS\_control$\%$print\_level} is negative.
\hslrestrictions {\tt m$\ge$n$\ge$1}.

\hslmethod 
\label{method}

% todo!

\hslexample
Consider fitting the function $y(t) = x_1e^{x_2 t}$ to data $(\bm{t}, \bm{y})$
using a non-linear least squares fit.\\
The residual function is given by
$$
   r_i(\vx; t_i, y_i) = x_1 e^{x_2 t_i} - y_i.
$$
We can calculate the Jacobian and Hessian as
$$
   J_i(\vx; t_i, y_i) = \left(\begin{array}{cc}
      e^{x_2 t_i} &
      t_i x_1 e^{x_2 t_i}
      \end{array}\right)
$$
$$
   H_i(\vx; t_i, y_i) = \left(\begin{array}{cc}
      1                 & t_i e^{x_2 t_i}    \\
      t_i e^{x_2 t_i}   & t_i^2 e^{x_2 t_i}
   \end{array}\right)
$$
Given the data
\begin{center}
   \begin{tabular}{l|*{5}{r}}
      $i$   & 1 & 2 & 3  & 4  & 5 \\
      \hline
      $t_i$ & 1 & 2 & 4  & 5  & 8 \\
      $y_i$ & 3 & 4 & 6 & 11 & 20
   \end{tabular}
\end{center}
and initial guess $\vx = (2.5, 0.25)$, the following code performs the fit.

\verbatiminput{../example/Fortran/nlls_example.f90}


\end{document}
