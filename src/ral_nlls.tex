\documentclass{hslspec}
\usepackage{color}
% set the release and package names

\newcommand{\libraryname}{RAL}
\newcommand{\packagename}{NLLS}
\newcommand{\fullpackagename}{\libraryname\_\packagename}
\newcommand{\versionum}{1.0.0}
\newcommand{\versiondate}{xx xx 20xx}
\newcommand{\version}{\versionum}
\newcommand{\scalarinteger}{is a scalar of type {\tt INTEGER}}
\newcommand{\scalarintegerio}{is an \intentout scalar of type {\tt INTEGER}}
\newcommand{\scalarintegerii}{is an \intentin scalar of type {\tt INTEGER}}
\newcommand{\scalarreal}{is a scalar of package type\ }
\newcommand{\ronearrayinteger}[1]{is a rank-1 array of type {\tt INTEGER} and size {\tt #1}}
\newcommand{\ronearrayreal}[1]{is a rank-1 array of package type and size {\tt #1}\ }
\newcommand{\ronearrayrealii}[1]{is an \intentin rank-1 array of package type and size {\tt #1}\ }
\newcommand{\ronearrayrealio}[1]{is an \intentout rank-1 array of package type and size {\tt #1}\ }
\begin{document}

\hslheader

\hslsummary
{\tt \fullpackagename} computes a solution to the nonlinear least-squares problem
\begin{equation}
\min_{x} \  F(x) := \frac{1}{2}\| r(x) \|^2,
\label{eq:nlls_problem}
\end{equation}

where $r_i(x) := y_i - f_i(x)$, $i = 1,\dots,m$, is the residual of the fit of the data $y$ to some nonlinear function $f : \mathbb{R}^n \rightarrow \mathbb{R}^m$.  The $n$ parameters we fit are given by $x$.

The algorithm is iterative.
At each point, $x_k$, we build a quadratic model of the function
\[
F(x_k) \approx m_k(x) := g_k^T x + \frac{1}{2} x^T H_k x.
\]
The `ideal' values in this model are $g_k = J_k^Tr(x_k)$ and $H_k = J_k^TJ_k + \sum_{i = 1}^m r_i(x) \nabla^2 r_i(x)$, where $J_k$ denotes the Jacobian of $r(x)$ at the point $x_k$.

Once we've formed our model, we solve a trust-region sub-problem of the form
\[
d = \arg \min_{x} \ m_k(x) \quad \mathrm{s.t.} \quad  \|x\|_B \leq \Delta,
\]
where $\Delta$ is the trust region radius and $B$ is a given symmetric positive definite matrix. 
We then calculate the quantity
\[\rho = \frac{F(x_k) - F(x_k + d)}{m_k(x_k) - m_k(x_k + d)}.\]
If this is sufficiently large we accept the point, and set $x_{k+1} = x_k + d$; if not we reduce the trust-region radius, $\Delta$, and solve the new trust-region sub-problem.  If the step is very successful -- in that $\rho$ is close to one -- we increase the trust-region radius.

This process continues until either the residual, $\|r(x_k)\|$, or a measure of the gradient,
$\|J_k^Tr(x_k)\| / \|r(x_k)\|$, is sufficiently small.


%!!!!!!!!!!!!!!!!!!!!!!!!!!!!
\hslattributes
\hslversions{\versionum\ ({\color{red}\versiondate)}}.
\hslinterfaces Fortran, MATLAB.
\hslIRDCZ Real (single, double).
\hslcalls {\tt \color{red} todo}.
\hsllanguage Fortran 2003 subset (F95+TR155581).  
\hsldate May 2015. 
\hslorigin The numerical analysis group.
\hslremark The development of this package was 
partially supported by EPSRC grant {\color{red}EP/xxxxxxx/x}.

%!!!!!!!!!!!!!!!!!!!!!!!!!!!
\newpage
\hslhowto

\subsection{Calling sequences}

Access to the package requires a {\tt USE} statement \\ \\
\indent\hspace{5mm}{\tt use nlls\_module} 
% \noindent 
% If it is required to use more than one module at the same time, the derived
% types  (see Section~\ref{derived types}) 
% must be renamed in one of the {\tt USE} statements.
\medskip

\noindent The user can then call the procedure:
\vspace{-0.1cm}
\begin{description}
\item {\tt ral\_nlls}  solves the nonlinear least squares problem (\ref{eq:nlls_problem}).
\end{description}

%%%%%%%%%%%%%%%%%%%%%% derived types %%%%%%%%%%%%%%%%%%%%%%%%

\hsltypes
\label{derived types}
For each problem, the user must employ the derived types defined by the
module to declare scalars of the types {\tt NLLS\_inform\_type}, and
{\tt NLLS\_control\_type}.
The following pseudocode illustrates this.
\begin{verbatim}
      use nlls_module
      ...
      type (NLLS_inform_type) :: status
      type (NLLS_control_type) :: control
      ...
\end{verbatim}
The components of {\tt NLLS\_control} and {\tt NLLS\_inform} are explained
in Sections~\ref{typecontrol} and \ref{typeinform}. 


%%%%%%%%%%%%%%%%%%%%%% argument lists %%%%%%%%%%%%%%%%%%%%%%%%
\hslarguments

\subsubsection{Integer and package types}
{\tt INTEGER} denotes default {\tt INTEGER}.
% and {\tt INTEGER(long)} denotes {\tt INTEGER(kind=selected\_int\_kind(18))}.
We use the term {\bf package type} to mean
default real if the single precision version is being used and
double precision real for the double precision version. {\color{red} (remove if only a single precision version is available).}

\subsubsection{To solve the non-linear least squares problem}
\label{sec:factorize}

To solve the non-linear least squares problem a call of the following form should be made:

\begin{verbatim}
   call RAL_NLLS(n, m, X, evalF, eval_J, eval_H, params, status, options)
\end{verbatim}

\begin{description}
\itt{n} \scalarintegerii that holds the number $n$ of 
parameters to be fitted; i.e., $n$ is the length of the unknown vector $x$.

\itt{m} \scalarintegerii that holds the number $m$ of 
data points available; i.e., $m$ is the number of functions $r_i$.

\itt{X} is an \intentinout\  rank-1 array of package type 
and size {\tt n}.  On entry it holds the initial guess, and on 
successful exit it holds the solution to the non-linear least squares problem.

\itt{eval\_f} is a {\tt PROCEDURE} that returns a vector giving the values of the function $r(x)$.  Further details of the format required are given in Section \ref{sec::function_eval}.

\itt{eval\_j} is a {\tt PROCEDURE} that returns the $m \times n$ Jacobian matrix, $J$, of the function $r(x)$.  Further details of the format required are given in Section \ref{sec::function_eval}.

\itt{eval\_hf} is a {\tt PROCEDURE} that returns the $n \times n$ matrix $\sum_{i=1}^mr_i(x)\nabla^2 r_i(x)$.  Further details of the format required are given in Section \ref{sec::function_eval}.

\itt{params} is an \inentin\ scalar of class {\tt user\_type} that must have the {\tt target} attribute.  The structure {\tt params} holds parameters that are to 
be passed to the user-defined routines {\tt eval\_f}, {\tt eval\_j}, and {\tt eval\_hf}.  
Here {\tt user\_type} is a user-defined extension of the {\tt params\_base\_type}; for more details, see Section \ref{sec::function_eval}.

\itt{control}is an \intentin\  scalar  of type {\tt NLLS\_control\_type}
(see Section~\ref{typecontrol}).

\itt{status} is an \intentinout\ scalar of type 
{\tt NLLS\_inform\_type}. Its components provide information about the execution
of the subroutine, as explained in Section~\ref{typeinform}.

\end{description}


\subsection{The user-supplied function evaluation routines}
\label{sec::function_eval}
In order to evaluate the function, Jacobian and Hessian at a point, the user must supply
subroutines that perform this operation that the code {\tt ral\_nlls} will call internally.  
We recommend that these routines are contained within a module.

In order to pass user-defined data into the evaluation calls, the {\tt params\_base\_type} must be extended to a {\tt user\_type}, as follows:
\begin{verbatim}
  module example

    use :: nlls_module, only : params_base_type
    implicit none

    type, extends( params_base_type ) :: user_type
       ! code declaring components of user_type 
    end type user_type
  
  contains 

    ! subroutines eval_F, eval_J and eval_HF

  end module example
\end{verbatim}
The module should then contain subroutines for evaluating the function, Jacobian, and Hessian.
The calling sequence of these subroutines much match that described below.

\begin{verbatim}
   eval_F( status, n, m, x, f, params )
\end{verbatim}

\begin{description}
  \itt{status} \scalarintegerio that reports on the success of the subroutine call.  A successful call must return {\tt status = 0}, otherwise an error will occur and the {\tt ral\_nlls} subroutine will be exited prematurely.

  \itt{n, m, \text{and} params} are as in the call to {\tt ral\_nlls}.

  \itt{params} is an \intentin scalar of class {\tt params\_base\_type} that holds parameters to be passed to the function.  This should be extended to {\tt user\_type} within the code by using a call of the form
\begin{verbatim}
   select type(params)
   type is(user_type)
     ! code that accesses components of params that were defined within user_type 
   end select
\end{verbatim}

  \itt{x} \ronearrayrealii{n} that holds the current point, $x_k$.
  
  \itt{f} \ronearrayrealio{m} that holds the function evaluated at the current point, $r(x_k)$.
  
\end{description}

\begin{verbatim}
   eval_J( status, n, m, x, J, params )
\end{verbatim}

\begin{description}
  \itt{status} \scalarintegerio that reports on the success of the subroutine call.  A successful call must return {\tt status = 0}, otherwise an error will occur and the {\tt ral\_nlls} subroutine will be exited prematurely.

  \itt{n, m, x, \text{and} params} are as in the call to {\tt eval\_F}.

  
  \itt{J} \ronearrayrealio{n*m} that holds the Jacobian evaluated at the current point held by columns as a vector.
  
\end{description}

\begin{verbatim}
   eval_HF( status, n, m, x, f, HF, params )
\end{verbatim}

\begin{description}
  \itt{status} \scalarintegerio that reports on the success of the subroutine call.  A successful call must return {\tt status = 0}, otherwise an error will occur and the {\tt ral\_nlls} subroutine will be exited prematurely.

  \itt{n, m, x, \text{and} params} are as in the call to {\tt eval\_F}.

  
  \itt{f} \ronearrayrealii{m} that holds the function evaluated at the current point, $r(x_k)$, as returned by a call to {\tt eval\_F}.

  \itt{HF} \ronearrayrealio{n*n} that holds the matrix $\sum_{i = 1}^m r_i(x_k)\nabla^2r_i(x_k)$, held by columns as a vector.
  
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\subsection{The control derived data type}
\label{typecontrol} 

The derived data type {\tt NLLS\_control} 
is used to hold controlling data. The components  are automatically 
given default values in the definition of the type.

\vspace{2mm}

\noindent {\bf Components that control printing}
\begin{description}

\itt{error} is a scalar of type {\tt INTEGER} with default value {\tt 6} that
is used as the output stream for error messages. If it is negative, these
messages will be suppressed.  

\itt{out} is a scalar of type {\tt INTEGER} with default value {\tt 6}
that is used as the output stream for general messages. If it is negative, these messages will be suppressed. 

\itt{print\_level} is a scalar of type {\tt INTEGER} with default value {\tt 0} that 
controls the level of output required. 
\begin{description} 
\item{\tt $\leq$ 0} No informational output will occur.
\item{\tt = 1} As 0, plus {\color{red} gives a one-line summary for each iteration}.
\item{\tt = 2} As 1, plus {\color{red} gives a summary of the inner iteration for each iteration}.
\item{\tt > 3} As 3, and gives increasingly verbose (debugging) output.
\end{description}
The default is {\tt diagnostics\_level} $=$ 0.


\noindent {\bf Components that control the main iteration}.

\begin{description}

\itt{maxit} \scalarinteger that gives an upper bound on the number
of iterations the algorithm is allowed to take before being stopped.  The default value is {\tt 100}.

\itt{model} \scalarinteger that specifies the model, $m_k(\cdot)}$, used.  Possible values are 
\begin{description}
  \item{\tt 1} First-order (no Hessian).
  \item{\tt 2} Second-order (exact Hessian).
  \item{\tt 3} Barely second-order (Hessian matrix approximated by the identity).
\end{description}
The default is {\tt model = 1}.

\itt{nlls\_method} \scalarinteger that specifies the method used to solve (or approximate the solution to) the trust-region sub problem.  Possible values are
\begin{description}
  \item{\tt 1} Powell's dogleg method (approximates the solution).
  \item{\tt 2} The Adachi-Iwata-Nakatsukasa-Takeda (AINT) method.
  \item{\tt 3} The More-Sorensen method.
\end{description}
The default is {\tt nlls\_method = 1}.

\itt{lls\_solver} \scalarinteger that specifies the method that is used to solve the linear least-squares problem {\color{red} as yet unused}

\itt{stop\_g\_absolute} \scalarreal that specifies the absolute tolerance for convergence.

\itt{stop\_g\_relative} \scalarreal that specifies the relative tolerance for convergence.

\itt{initial\_radius} \scalarreal that specifies the initial trust-region radius, $\Delta$.

\itt{maximum\_radius} \scalarreal that specifies the maximum size permitted for the trust-region radius.

\itt{eta\_successful} \scalarreal that specifies the smallest value of $\rho$ such that we accept the step.  

\itt{eta\_very\_successful} \scalarreal that specifies the value of $\rho$ after which we increase the trust-region radius.

\itt{eta\_too\_successful} \scalarreal that specifies that value of $\rho$ after which we accept the step, but keep the trust-region radius unchanged.

\itt{radius\_increase} \scalarreal that specifies the factor to increase the trust-region radius by.

\itt{radius\_reduce} \scalarreal that specifies the factor to decrease the trust-region radius by.

\itt{radius\_reduce\_max} \scalarreal that specifies the smallest factor by which we can reduce the trust-region radius {\color{red} coded up, but always inactive until a more sophisticated increase/reduction strategy is employed}.

\end{description}


\subsection{The derived data type for holding information}
\label{typeinform} 
The derived data type {\tt NLLS\_inform\_type} is used
to hold information from the execution of {\tt RAL\_NLLS}.
The components are:
\begin{description}
\itt{status} \scalarinteger that gives the exit status of the subroutine.  See Section {\color{red} ???} for details.
\itt{alloc\_status} \scalarinteger that gives the status of the last attempted allocation/deallocation.
\itt{iter} \scalarinteger that gives the total number of iterations performed.
\end{description}

%%%%%%%%%%%%%%%%%%%%%% Warning and error messages %%%%%%%%%%%%%%%%%%%%%%%%

\hslerrors

A successful return from a subroutine in the package is indicated by 
{\tt info$\%$flag} having the value zero.  
A non-zero value is associated with an error message that by default will  
be output on unit {\tt control$\%$unit\_error}. 

Possible values are:
\begin{description}
\item{} {\tt 1} Maximum number of iterations reached without convergence.
\item{} {\tt 2} Error from evaluating a function/Jacobian/Hessian.
\item{} {\tt 3} Unsupported choice of model.
\item{} {\tt 4} Error return from an {\tt lapack} routine.
\end{description}

\hslgeneral


\hslio 
   Error messages on unit {\tt control$\%$lp} and warning
   and diagnostic messages on units {\tt control$\%$wp} and {\tt control$\%$mp},
   respectively. These have default value {\tt 6};
   printing of these messages is suppressed if the relevant unit number
   is negative or if {\tt print\_level} is negative.
\hslrestrictions {\tt m$\ge$n$\ge$1}. 

\hslmethod 
\label{method}

% todo!

\hslexample

% todo!


\end{document}
